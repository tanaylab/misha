<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manual • misha</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Manual">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">misha</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">5.3.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Database-Formats.html">Database Formats and Multi-Contig Support</a>
    </li>
    <li>
      <a href="../articles/Genomes.html">Genomes</a>
    </li>
    <li>
      <a href="../articles/Manual.html">Manual</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/tanaylab/misha/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Manual</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/tanaylab/misha/blob/5.3.1/vignettes/Manual.Rmd" class="external-link"><code>vignettes/Manual.Rmd</code></a></small>
      <div class="hidden name"><code>Manual.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://tanaylab.github.io/misha/" class="external-link">misha</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gdb.init.html">gdb.init_examples</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="package-misha---user-manual">Package ‘misha’ - User Manual<a class="anchor" aria-label="anchor" href="#package-misha---user-manual"></a>
</h2>
<p><strong>misha</strong> package is intended to help users to
efficiently analyze genomic data achieved from various experiments. The
data must be stored in <em>Genomic Database</em> in certain format that
is described later in this document. In addition the document describes
fundamental concepts of the package such as <em>track expression</em>,
<em>iterators</em>, etc.</p>
<div class="section level3">
<h3 id="genomic-database">Genomic Database<a class="anchor" aria-label="anchor" href="#genomic-database"></a>
</h3>
<p>Genomic Database starts with a <em>root</em> (also frequently
referred as <em>GROOT</em>), i.e. top directory containing certain
subdirectories and files. A new database can be created using
<code>gdb.create_genome</code> and <code>gdb.create</code> functions.
This is the easiest way to do it, see the “Genomes” vignette for more
details. One can also build a database manually by generating all the
necessary components that will be described later in this document.</p>
<p>Before the data in a Genomic Database can be accessed one must
establish connection with it by calling <code>gdb.init</code> function.
On launch the package connects to a Genomic Database located in
<code>PACKAGEDIR/trackdb/test</code> which serves all the examples in
the reference manual.</p>
<p>A valid Genomic Database should contain the following files and
subdirectories:</p>
<ul>
<li>
<code>chrom_sizes.txt</code>: is a file containing the list of
chromosomes and their sizes.</li>
<li>
<code>tracks</code>: is a directory that servers as a repository for
all <em>tracks</em> and <em>interval sets</em>. May contain other
subdirectories.</li>
<li>
<code>pssms</code>: is a directory containing PSSM sets (PSSM data
and PSSM key files).</li>
<li>
<code>seq</code>: is a directory containing full genomic
sequences.</li>
</ul>
<p><code>pssms</code> and <code>seq</code> directories are optional and
are required only by a subset of functions in the package.</p>
<p>An example of a Genomic Database file structure:</p>
<pre><code>hg38/              &lt;- Genomic Database root directory
   chrom_sizes.txt
   .ro_attributes  &lt;- List of read-only attributes
   pssms/             &lt;- (optional)
      motif1.data        &lt;- pssm data file
      motif1.key         &lt;- pssm key file
      mypssm.data        &lt;- ...
      mypssm.key         &lt;- ...
   seq/               &lt;- (optional)
      genome.seq         &lt;- indexed format: single sequence file
      genome.idx         &lt;- indexed format: index file
      OR
      chr1.seq           &lt;- per-chromosome format: separate files
      chr2.seq           &lt;- ...
      chr3.seq           &lt;- ...
   tracks/
      tss.interv         &lt;- small intervals set = tss
      big_data.interv/   &lt;- big intervals set = big_data (per-chromosome format)
         .meta              &lt;- summary of the intervals set
         chr1               &lt;- chrom files
         chr5               &lt;- ...
      indexed_intervals.interv/  &lt;- big intervals set (indexed format)
         intervals.dat      &lt;- consolidated interval data
         intervals.idx      &lt;- index file
      rpt.track/         &lt;- track = rpt (per-chromosome format)
         .attributes        &lt;- track attributes (optional)
         chr1               &lt;- chrom files
         chr2               &lt;- ...
         chr3               &lt;- ...
         vars/              &lt;- track variables (optional)
             myresult           &lt;- track variable
      indexed_track.track/   &lt;- track (indexed format)
         track.dat          &lt;- consolidated track data
         track.idx          &lt;- index file
         .attributes        &lt;- track attributes (optional)
         vars/              &lt;- track variables (optional)
      test/
         intervals1.interv  &lt;- intervals = test.intervals1
         track1.track/      &lt;- track = test.track1
         .attributes        &lt;- track attributes (optional)
         chr1               &lt;- chrom files
         chr2               &lt;- ...
         chr3               &lt;- ...
      savta/
         fourC.track/    &lt;- track = savtra.fourC
            chr1               &lt;- chrom files
            chr2               &lt;- ...
            chr3               &lt;- ...</code></pre>
</div>
<div class="section level3">
<h3 id="file-formats">File Formats<a class="anchor" aria-label="anchor" href="#file-formats"></a>
</h3>
<div class="section level4">
<h4 id="chrom_sizes-txt">
<code>chrom_sizes.txt</code><a class="anchor" aria-label="anchor" href="#chrom_sizes-txt"></a>
</h4>
<p><code>chrom_sizes.txt</code> file must be located under the root
directory of Genomic Database. This file lists the chromosomes and their
sizes. The chromosome name appears in the first column, the size is
indicated in the second column. The chromosome name should appear
without “chr” prefix. The two columns are separated by tab character.
Example:</p>
<pre class="tsv"><code>1    247249719
2    242951149
3    199501827
X    154913754
Y    57772954</code></pre>
</div>
<div class="section level4">
<h4 id="seq-files">Seq Files<a class="anchor" aria-label="anchor" href="#seq-files"></a>
</h4>
<p>Genomic sequences are stored in the <code>seq</code> directory. Two
formats are supported:</p>
<div class="section level5">
<h5 id="indexed-format-recommended">Indexed Format (Recommended)<a class="anchor" aria-label="anchor" href="#indexed-format-recommended"></a>
</h5>
<p>The indexed format uses two files: - <code>genome.seq</code>: Single
binary file containing concatenated sequences for all contigs -
<code>genome.idx</code>: Binary index mapping contig names to positions
in genome.seq</p>
<p>This format provides better performance and scalability, especially
for genomes with many contigs. It is the default format created by
<code><a href="../reference/gdb.create.html">gdb.create()</a></code>.</p>
<p><strong>Format Specifications:</strong></p>
<p>The <code>genome.idx</code> file has the following structure: -
<strong>Header (24 bytes)</strong>: - Magic number:
<code>"MISHAIDX"</code> (8 bytes) - Index version: <code>uint32_t</code>
(4 bytes, currently 1) - Number of contigs: <code>uint32_t</code> (4
bytes) - CRC64-ECMA checksum: <code>uint64_t</code> (8 bytes)</p>
<ul>
<li>
<strong>Entries</strong> (one per contig):
<ul>
<li>Chromosome ID: <code>uint32_t</code> (4 bytes) - alphabetical rank
(0, 1, 2, …)</li>
<li>Name length: <code>uint16_t</code> (2 bytes)</li>
<li>Name: UTF-8 string (not null-terminated)</li>
<li>Offset in genome.seq: <code>uint64_t</code> (8 bytes)</li>
<li>Sequence length: <code>uint64_t</code> (8 bytes)</li>
<li>Reserved: <code>uint64_t</code> (8 bytes, currently zeros)</li>
</ul>
</li>
</ul>
<p>All multi-byte integers are stored in little-endian byte order.</p>
</div>
<div class="section level5">
<h5 id="per-chromosome-format">Per-Chromosome Format<a class="anchor" aria-label="anchor" href="#per-chromosome-format"></a>
</h5>
<p>Each contig has a separate <code>.seq</code> file containing its
genomic sequence as a contiguous string of ASCII characters. Files are
named <code>chrXXX.seq</code> where <code>XXX</code> is the contig name
from <code>chrom_sizes.txt</code>.</p>
<p>Example of a short (25 base pairs) Seq file:</p>
<pre class="csv"><code><span><span class="va">ggtgaAGccctggagattcttatta</span></span></code></pre>
<p>To create a database in the per-chromosome format, use
<code>gdb.create(..., format = "per-chromosome")</code>.</p>
</div>
</div>
<div class="section level4">
<h4 id="track-files">Track Files<a class="anchor" aria-label="anchor" href="#track-files"></a>
</h4>
<p>Tracks can be stored in two different formats: <strong>per-chromosome
format</strong> or <strong>indexed format</strong>.</p>
<div class="section level5">
<h5 id="per-chromosome-format-1">Per-Chromosome Format<a class="anchor" aria-label="anchor" href="#per-chromosome-format-1"></a>
</h5>
<p>In the traditional per-chromosome format, each chromosome’s track
data is stored in a separate file within a track directory (e.g.,
<code>tracks/mytrack.track/chr1</code>,
<code>tracks/mytrack.track/chr2</code>, etc.). This format works well
for genomes with a small number of chromosomes.</p>
</div>
<div class="section level5">
<h5 id="indexed-format-recommended-for-multi-contig-genomes">Indexed Format (Recommended for Multi-Contig Genomes)<a class="anchor" aria-label="anchor" href="#indexed-format-recommended-for-multi-contig-genomes"></a>
</h5>
<p>The indexed format consolidates all chromosome data into two files: -
<code>track.dat</code>: Single binary file containing concatenated track
data for all chromosomes - <code>track.idx</code>: Binary index mapping
chromosome IDs to positions in track.dat</p>
<p>This format dramatically reduces file descriptor usage for genomes
with many contigs (e.g., draft assemblies with thousands of scaffolds)
and improves performance for parallel access.</p>
<p><strong>Format Specifications:</strong></p>
<p>The <code>track.idx</code> file has the following structure: -
<strong>Header (36 bytes)</strong>: - Magic number:
<code>"MISHATDX"</code> (8 bytes) - Index version: <code>uint32_t</code>
(4 bytes, currently 1) - Track type: <code>uint32_t</code> (4 bytes) -
0=dense, 1=sparse, 2=array - Number of contigs: <code>uint32_t</code> (4
bytes) - Flags: <code>uint64_t</code> (8 bytes) - bit 0 indicates
little-endian - CRC64-ECMA checksum: <code>uint64_t</code> (8 bytes)</p>
<ul>
<li>
<strong>Entries</strong> (24 bytes per contig):
<ul>
<li>Chromosome ID: <code>uint32_t</code> (4 bytes)</li>
<li>Offset in track.dat: <code>uint64_t</code> (8 bytes)</li>
<li>Data length: <code>uint64_t</code> (8 bytes)</li>
<li>Reserved: <code>uint32_t</code> (4 bytes, for future use)</li>
</ul>
</li>
</ul>
<p>All multi-byte integers are stored in little-endian byte order.</p>
<p><strong>Converting to Indexed Format:</strong></p>
<p>Existing per-chromosome tracks can be converted to indexed format
using <code><a href="../reference/gtrack.convert_to_indexed.html">gtrack.convert_to_indexed()</a></code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Convert a track to indexed format</span></span>
<span><span class="fu"><a href="../reference/gtrack.convert_to_indexed.html">gtrack.convert_to_indexed</a></span><span class="op">(</span><span class="st">"my_track"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check track format</span></span>
<span><span class="va">info</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gtrack.info.html">gtrack.info</a></span><span class="op">(</span><span class="st">"my_track"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">info</span><span class="op">$</span><span class="va">format</span><span class="op">)</span> <span class="co"># "indexed" or "per-chromosome"</span></span></code></pre></div>
<p><strong>Supported Track Types:</strong> Dense (fixed-bin), Sparse,
and Array tracks (1D only) can use indexed format. 2D tracks and virtual
tracks are not supported for indexed format.</p>
<p><strong>Backward Compatibility:</strong> The indexed format is fully
transparent to all misha functions. Both formats can coexist in the same
database and are used identically in track expressions and analysis
functions.</p>
<p><strong>Validation Limits:</strong> To prevent issues with corrupted
or malicious index files, the following limits are enforced:</p>
<ul>
<li>
<strong>Maximum contigs per index</strong>: 20,000,000 (applies to
genome.idx, track.idx, intervals.idx)</li>
<li>
<strong>Maximum contig name length</strong>: 1,024 bytes</li>
</ul>
</div>
</div>
<div class="section level4">
<h4 id="pssm-set">PSSM Set<a class="anchor" aria-label="anchor" href="#pssm-set"></a>
</h4>
<p>Each <em>PSSM Set</em> consists of two files: <em>PSSM key</em> and
<em>PSSM data</em>. The files should be named <code>XXX.key</code> and
<code>XXX.data</code> accordingly, where <code>XXX</code> is the name of
PSSM set. Both files must be placed into <code>pssms</code>
directory.</p>
<div class="section level5">
<h5 id="pssm-key">PSSM Key<a class="anchor" aria-label="anchor" href="#pssm-key"></a>
</h5>
<p><em>PSSM Key</em> file contains description of PSSMs in the following
format (columns are separated by tab character):</p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>Integer</td>
<td>Unique ID (referenced in PSSM Data file)</td>
</tr>
<tr class="even">
<td>Sequence</td>
<td>String</td>
<td>PSSM sequence</td>
</tr>
<tr class="odd">
<td>Bidirectional</td>
<td>‘0’ or ‘1’</td>
<td>If Bidirectional is ‘1’ energy is calculated on complementary strand
as well</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="tsv"><code>0    *************ATTAAT**************    1
1    *********A*ACACACACA*****A*******    1
2    *************AAAATGGC*G**********    1
3    *************ACTGCTTG************    1
4    ****WW**GTWGCATACTTTT*GGCG*******    1
5    *********C*RGCAACATKTTG**********    1
6    ****G*G*G*G*GAGCGAGA*RG**********    1
7    **************CCGAAG*************    1</code></pre>
</div>
<div class="section level5">
<h5 id="pssm-data">PSSM Data<a class="anchor" aria-label="anchor" href="#pssm-data"></a>
</h5>
<p><em>PSSM Data</em> file contains probability matrices for each PSSM
key in the following format (columns are separated by tab
character):</p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>Integer</td>
<td>Unique ID (must appear in PSSM Key file)</td>
</tr>
<tr class="even">
<td>Position</td>
<td>Integer</td>
<td>Zero based position in the range of [0, length(PSSM
sequence)-1]</td>
</tr>
<tr class="odd">
<td>Probability of ‘A’</td>
<td>Numeric</td>
<td>Probability of ‘A’ in the range of [0, 1]</td>
</tr>
<tr class="even">
<td>Probability of ‘C’</td>
<td>Numeric</td>
<td>Probability of ‘C’ in the range of [0, 1]</td>
</tr>
<tr class="odd">
<td>Probability of ‘G’</td>
<td>Numeric</td>
<td>Probability of ‘G’ in the range of [0, 1]</td>
</tr>
<tr class="even">
<td>Probability of ‘T’</td>
<td>Numeric</td>
<td>Probability of ‘T’ in the range of [0, 1]</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section level3">
<h3 id="intervals">Intervals<a class="anchor" aria-label="anchor" href="#intervals"></a>
</h3>
<div class="section level4">
<h4 id="d-intervals">1D Intervals<a class="anchor" aria-label="anchor" href="#d-intervals"></a>
</h4>
<p>A <strong>1D interval</strong> (or one-dimensional interval)
represents a genomic section. It is defined by
<code>(chrom, start, end)</code> where <code>start</code> and
<code>end</code> are genomic coordinates (<code>start &lt; end</code>).
The coordinates are zero-based, meaning the chromosome starts at
coordinate 0. The end coordinate marks the last coordinate in the
section plus 1. To represent a point in the genome at coordinate
<code>X</code>, one should create an interval with start coordinate set
to <code>X</code> and end coordinate set to <code>X + 1</code>.</p>
</div>
<div class="section level4">
<h4 id="d-intervals-1">2D Intervals<a class="anchor" aria-label="anchor" href="#d-intervals-1"></a>
</h4>
<p>A <strong>2D interval</strong> (or two-dimensional interval)
represents a rectangle in a genomic space. It is defined by
<code>(chrom_1, start_1, end_1, chrom_2, start_2, end_2)</code>, where
<code>start_1, start_2, end_1,</code> and <code>end_2</code> are start
and end coordinates that mark the limits of a rectangle.</p>
</div>
<div class="section level4">
<h4 id="interval-sets">Interval Sets<a class="anchor" aria-label="anchor" href="#interval-sets"></a>
</h4>
<p>Multiple intervals can be combined into a table, known as an
<strong>interval set</strong> or often simply referred to as
<strong>intervals</strong>. This table is represented by a data frame.
In the case of 1D intervals, the data frame must have the first three
columns named <code>chrom</code>, <code>start</code>, and
<code>end</code>. Similarly, 2D intervals must have the first six
columns named <code>chrom1</code>, <code>start1</code>,
<code>end1</code>, <code>chrom2</code>, <code>start2</code>, and
<code>end2</code>.</p>
<p>Additional columns might be added to the intervals, and some of them
might be utilized by various functions. For instance, the
<code>gintervals.neighbors</code> function uses the <code>strand</code>
column if it is presented in 1D intervals (should come after the regular
three columns). Use <code>gintervals</code> and
<code>gintervals.2d</code> functions to create 1D and 2D intervals,
respectively.</p>
<p>Both 1D and 2D intervals are prevalent in various functions. Some of
these functions manipulate the intervals (unify, intersect, etc.).
Others use the intervals to limit the function’s scope. There are also
functions that perform their calculation for each interval in the
interval set.</p>
</div>
<div class="section level4">
<h4 id="dual-intervals">Dual Intervals<a class="anchor" aria-label="anchor" href="#dual-intervals"></a>
</h4>
<p><strong>Dual intervals</strong> is a list containing two elements.
The first element is a 1D interval set, while the second element is a 2D
interval set.</p>
<p>The <code>.misha$ALLGENOME</code> variable is frequently used as a
default value for the intervals argument. <code>.misha$ALLGENOME</code>
is an interval set of a dual type. <code>.misha$ALLGENOME[[1]]</code>
represents a set of intervals that cover the entire genome (1D), while
<code>.misha$ALLGENOME[[2]]</code> contains all the possible pairs
between the chromosomes (2D). One can also use
<code>gintervals.all</code> and <code>gintervals.2d.all</code> functions
to return all 1D or 2D intervals.</p>
</div>
<div class="section level4">
<h4 id="serializing-intervals-big-and-small-interval-sets">Serializing Intervals, Big and Small Interval Sets<a class="anchor" aria-label="anchor" href="#serializing-intervals-big-and-small-interval-sets"></a>
</h4>
<p>Interval sets can be saved in the Genomic Database. Use the
<code>gintervals.save</code> and <code>gintervals.load</code> functions
to save or load an interval set from the database, and
<code>gintervals.update</code> to update/add/delete a certain chromosome
from the set.</p>
<p>Internally, interval sets can be stored in two different formats:
<strong>small interval set</strong> or <strong>big interval
set</strong>. The specific format is chosen depending on the size of the
interval set. Big format is selected for interval sets that contain more
than <code>gbig.intervals.size</code> intervals
(<code>gbig.intervals.size</code> is set via <code>options</code>),
while smaller sets are stored in the small format. Use
<code>gintervals.is.bigset</code> to determine the format of the stored
interval set.</p>
<p>Saved interval sets in the small format can be seamlessly used in all
functions and track expressions without the need to explicitly load
them.</p>
<div class="section level5">
<h5 id="interval-set-storage-formats">Interval Set Storage Formats<a class="anchor" aria-label="anchor" href="#interval-set-storage-formats"></a>
</h5>
<p>Big interval sets can be stored in two formats:
<strong>per-chromosome format</strong> or <strong>indexed
format</strong>.</p>
<p><strong>Per-Chromosome Format:</strong> In this traditional format,
intervals for each chromosome (or chromosome pair for 2D intervals) are
stored in separate files within an interval set directory. For 1D
intervals: <code>myintervals.interv/chr1</code>, <code>chr2</code>, etc.
For 2D intervals: <code>myintervals.interv/chr1-chr2</code>,
<code>chr1-chr3</code>, etc.</p>
<p><strong>Indexed Format (Recommended for Multi-Contig
Genomes):</strong> The indexed format consolidates all chromosomes into
two files, dramatically reducing file descriptor usage for genomes with
many contigs.</p>
<p><strong>1D Intervals</strong> use: - <code>intervals.dat</code>:
Binary file with concatenated interval data -
<code>intervals.idx</code>: Binary index file (36-byte header + 24 bytes
per contig)</p>
<p>The <code>intervals.idx</code> file structure: - <strong>Header (36
bytes)</strong>: - Magic: <code>"MISHAI1D"</code> (8 bytes) - Version:
<code>uint32_t</code> (4 bytes) - Number of entries:
<code>uint32_t</code> (4 bytes) - Flags: <code>uint64_t</code> (8 bytes)
- bit 0 indicates little-endian - CRC64-ECMA checksum:
<code>uint64_t</code> (8 bytes) - Reserved: <code>uint32_t</code> (4
bytes)</p>
<ul>
<li>
<strong>Entries</strong> (24 bytes per contig):
<ul>
<li>Chromosome ID: <code>uint32_t</code> (4 bytes)</li>
<li>Offset: <code>uint64_t</code> (8 bytes)</li>
<li>Length: <code>uint64_t</code> (8 bytes)</li>
<li>Reserved: <code>uint32_t</code> (4 bytes)</li>
</ul>
</li>
</ul>
<p><strong>2D Intervals</strong> use: - <code>intervals2d.dat</code>:
Binary file with concatenated pair data - <code>intervals2d.idx</code>:
Binary index file (40-byte header + 28 bytes per pair)</p>
<p>The <code>intervals2d.idx</code> file structure: - <strong>Header (40
bytes)</strong>: - Magic: <code>"MISHAI2D"</code> (8 bytes) - Version:
<code>uint32_t</code> (4 bytes) - Number of entries:
<code>uint32_t</code> (4 bytes) - Flags: <code>uint64_t</code> (8 bytes)
- CRC64-ECMA checksum: <code>uint64_t</code> (8 bytes) - Reserved:
<code>uint64_t</code> (8 bytes)</p>
<ul>
<li>
<strong>Entries</strong> (28 bytes per pair):
<ul>
<li>Chromosome 1 ID: <code>uint32_t</code> (4 bytes)</li>
<li>Chromosome 2 ID: <code>uint32_t</code> (4 bytes)</li>
<li>Offset: <code>uint64_t</code> (8 bytes)</li>
<li>Length: <code>uint64_t</code> (8 bytes)</li>
<li>Reserved: <code>uint32_t</code> (4 bytes)</li>
</ul>
</li>
</ul>
<p><strong>Note:</strong> Only non-empty chromosome pairs are stored in
the 2D index, avoiding O(N²) space overhead.</p>
<p><strong>Converting to Indexed Format:</strong></p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Convert 1D interval set to indexed format</span></span>
<span><span class="fu"><a href="../reference/gintervals.convert_to_indexed.html">gintervals.convert_to_indexed</a></span><span class="op">(</span><span class="st">"my_intervals"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Convert 2D interval set to indexed format</span></span>
<span><span class="fu"><a href="../reference/gintervals.2d.convert_to_indexed.html">gintervals.2d.convert_to_indexed</a></span><span class="op">(</span><span class="st">"my_2d_intervals"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Convert and remove old per-chromosome files</span></span>
<span><span class="fu"><a href="../reference/gintervals.convert_to_indexed.html">gintervals.convert_to_indexed</a></span><span class="op">(</span><span class="st">"my_intervals"</span>, remove.old <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>All multi-byte integers are stored in little-endian byte order. The
indexed format is fully backward compatible with all misha
functions.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 'annotations' is an intervals set saved in Genomic Database</span></span>
<span><span class="fu"><a href="../reference/gintervals.intersect.html">gintervals.intersect</a></span><span class="op">(</span><span class="st">"annotations"</span>, <span class="fu"><a href="../reference/gintervals.html">gintervals</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Likewise, big interval sets can be used in many but not all
functions. A notable exception is <code>gintervals.load</code> that
allows loading only a single chromosome (or a chromosome pair for 2D
cases) of a big intervals set.</p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="tracks">Tracks<a class="anchor" aria-label="anchor" href="#tracks"></a>
</h3>
<p>A <strong>Track</strong> is a data structure that allows binding
numeric data (floating point values) to a genomic space (a set of
genomic intervals). The data in the tracks can typically be accessed
through <strong>track expressions</strong> that are widely used by
various functions of the package.</p>
<p>Two fundamental types of tracks exist: <strong>1D</strong> and
<strong>2D</strong>.</p>
<div class="section level4">
<h4 id="d-track">1D Track<a class="anchor" aria-label="anchor" href="#d-track"></a>
</h4>
<p>A <strong>1D track</strong> (or one-dimensional track) maps numeric
values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>V</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">V_0, ..., V_n</annotation></semantics></math>
to non-overlapping 1D intervals. The package supports two formats of 1D
tracks: <strong>Dense</strong> (sometimes also referred to as
<strong>Fixed Bin</strong>) and <strong>Sparse</strong>.</p>
<p>For a Dense track, the size of the genomic interval is always fixed
and called <strong>bin size</strong>. Numeric values are stored for all
genomic intervals that cover the genome, although some values can be
<code>NaN</code>. A Dense track file appears as a continuous chunk of
values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>V</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">V_0, ..., V_n</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mi>i</mi></msub><annotation encoding="application/x-tex">V_i</annotation></semantics></math>
maps to an interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>*</mo><mi>i</mi><mo>,</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>*</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[binsize * i, binsize * (i+1))</annotation></semantics></math>.
Dense track files do not store interval coordinates, allowing them to
represent large amounts of numeric data compactly. The size of a Dense
track is inversely proportional to the bin size. Random access to a
value at a given coordinate has constant complexity, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.</p>
<p>Sparse tracks offer more flexibility compared to Dense tracks. Each
numeric value can map to a genomic interval of any size. The size of a
Sparse track is proportional to the number of numeric values (excluding
<code>NaN</code>s). On the downside, the complexity of random access to
a value at a given coordinate is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the number of values in the track.</p>
<p>To summarize the differences between Dense and Sparse tracks:</p>
<table class="table">
<colgroup>
<col width="16%">
<col width="41%">
<col width="41%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Dense</th>
<th>Sparse</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Optimal use case</td>
<td>Data covering nearly the whole genome</td>
<td>Data covering a limited portion of the genome</td>
</tr>
<tr class="even">
<td>Values stored</td>
<td>Per bin (interval of a fixed size)</td>
<td>Per interval of an arbitrary size</td>
</tr>
<tr class="odd">
<td>Random access complexity</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td>Disk usage</td>
<td>4 bytes per bin</td>
<td>20 bytes per value</td>
</tr>
</tbody>
</table>
<p>1D tracks can be created by various functions, such as
<code>gtrack.create</code>, <code>gtrack.create_sparse</code>,
<code>gtrack.import_set</code>, and more.</p>
</div>
<div class="section level4">
<h4 id="array-track">Array Track<a class="anchor" aria-label="anchor" href="#array-track"></a>
</h4>
<p>An <strong>Array track</strong> is similar to a Sparse track in that
it maps data to one-dimensional intervals of any size. However, unlike
Sparse tracks, an Array track can map multiple values to each interval.
Array tracks thus store large amounts of data in one track - a task that
would otherwise require numerous tracks.</p>
<p>The values in an Array track are organized into
<strong>columns</strong>, each with a name and an index. You can view it
as an NxM table, where N is the number of intervals, and M is the number
of columns. The size of an Array track is proportional to the total
number of numeric values stored (excluding <code>NaN</code>s).</p>
<p>As useful as they are, Array tracks should not replace Dense or
Sparse tracks. A single Sparse track will always be more compact and
efficient than an Array track holding only one column.</p>
<p>You can create Array tracks with the <code>gtrack.array.import</code>
function.</p>
</div>
<div class="section level4">
<h4 id="d-track-1">2D Track<a class="anchor" aria-label="anchor" href="#d-track-1"></a>
</h4>
<p>A <strong>2D track</strong> (or two-dimensional track) maps numeric
values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>V</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">V_0, ..., V_n</annotation></semantics></math>
to non-overlapping 2D intervals. These are often used to represent
interactions between different parts of the genome.</p>
<p>2D tracks are stored internally in <strong>chunks</strong> with each
chunk containing multiple track values. When accessing a track value,
its entire chunk is loaded into memory. The byte size of a chunk,
determined by the <code>gtrack.chunk.size</code> option, is a tradeoff
between single value access (smaller chunk) and multiple value access
(larger chunk).</p>
<p>When accessing multiple track values, multiple chunks might be loaded
into memory. Given the potential size of 2D tracks, the total number of
chunks in memory can be limited using the <code>gtrack.num.chunks</code>
parameter.</p>
<p>Typically, 2D tracks use the <strong>Rectangles</strong> format.
However, a more space-efficient <strong>Points</strong> format exists,
similar in behavior to Rectangles. There’s also a
<strong>Computed</strong> format, which is beyond the scope of this
documentation.</p>
<p>Rectangles tracks: <code>gtrack.create</code>,
<code>gtrack.2d.create</code>.</p>
<p>Points tracks: <code>gtrack.2d.import_contacts</code>.</p>
</div>
<div class="section level4">
<h4 id="track-as-an-intervals-set">Track as an Intervals Set<a class="anchor" aria-label="anchor" href="#track-as-an-intervals-set"></a>
</h4>
<p>Tracks represent sets of intervals, augmented with values, and can
therefore replace interval sets in functions like <code>gextract</code>,
<code>gintervals.neighbors</code>, and
<code>gintervals.chrom_sizes</code>. The only exception is
<strong>Dense</strong> tracks which can’t be used in place of interval
sets.</p>
</div>
<div class="section level4">
<h4 id="track-attributes">Track Attributes<a class="anchor" aria-label="anchor" href="#track-attributes"></a>
</h4>
<p>Beyond numeric data, tracks can store metadata, such as descriptions
or sources. This metadata is stored as name-value pairs or attributes
with the value being a string. Tracks created using
<code>gtrack.create</code>, <code>gtrack.smooth</code>, etc.,
automatically have <code>created.by</code>, <code>created.date</code>,
and <code>description</code> attributes.</p>
<p>While there’s no strict rule, attributes typically store short
strings. For other data formats, consider using <strong>track
variables</strong>.</p>
<p>Attribute management: - Retrieval/Modification:
<code>gtrack.attr.get</code>, <code>gtrack.attr.set</code>. - Bulk
Actions: <code>gtrack.attr.export</code>,
<code>gtrack.attr.import</code>. - Search by Pattern:
<code>gtrack.ls</code>.</p>
<p>Some attributes are read-only, like <code>created.by</code> and
<code>created.date</code>. Use <code>gdb.get_readonly_attrs</code> and
<code>gdb.set_readonly_attrs</code> to manage these.</p>
</div>
<div class="section level4">
<h4 id="track-variables">Track Variables<a class="anchor" aria-label="anchor" href="#track-variables"></a>
</h4>
<p>Track variables store statistics, computation results, historical
data, etc., related to a track. Unlike attributes, they can store data
in any format.</p>
<p>Variable management: - Retrieval/Modification/Removal:
<code>gtrack.var.get</code>, <code>gtrack.var.set</code>,
<code>gtrack.var.rm</code>. - List variables:
<code>gtrack.var.ls</code>.</p>
</div>
<div class="section level4">
<h4 id="track-attributes-vs--track-variables">Track Attributes vs. Track Variables<a class="anchor" aria-label="anchor" href="#track-attributes-vs--track-variables"></a>
</h4>
<p>Both track attributes and variables store track metadata, but they
have distinct uses:</p>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Track Attributes</th>
<th>Track Variables</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Use Case</td>
<td>Track metadata as short strings (e.g., description)</td>
<td>Arbitrary track-associated data</td>
</tr>
<tr class="even">
<td>Value Type</td>
<td>String</td>
<td>Any</td>
</tr>
<tr class="odd">
<td>Single Value Retrieval</td>
<td><code>gtrack.attr.get</code></td>
<td><code>gtrack.var.get</code></td>
</tr>
<tr class="even">
<td>Single Value Modification</td>
<td><code>gtrack.attr.set</code></td>
<td><code>gtrack.var.set</code></td>
</tr>
<tr class="odd">
<td>Bulk Retrieval</td>
<td><code>gtrack.attr.export</code></td>
<td>N/A</td>
</tr>
<tr class="even">
<td>Bulk Modification</td>
<td><code>gtrack.attr.import</code></td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>Object Names Retrieval</td>
<td><code>gtrack.attr.export</code></td>
<td><code>gtrack.var.ls</code></td>
</tr>
<tr class="even">
<td>Object Removal</td>
<td>
<code>gtrack.attr.set</code> (with an empty string)</td>
<td><code>gtrack.var.rm</code></td>
</tr>
<tr class="odd">
<td>Search by Value</td>
<td><code>gtrack.ls</code></td>
<td>N/A</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section level3">
<h3 id="track-expressions">Track Expressions<a class="anchor" aria-label="anchor" href="#track-expressions"></a>
</h3>
<div class="section level4">
<h4 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h4>
<p><em>Track expression</em> is a key concept of the package. Track
expressions are widely used in various functions (<code>gscreen</code>,
<code>gextract</code>, <code>gdist</code>, …).</p>
<p>Track expression is a character string that closely resembles a valid
R expression. Just like any other R expression it may include
conditions, functions and variables defined beforehand.
<code>"1 &gt; 2"</code>, <code>"mean(1:10)"</code> and
<code>"myvar &lt; 17"</code> are all valid track expressions. Unlike
regular R expressions track expression might also contain track names or
<em>virtual track</em> names.</p>
<p>How does a track expression get evaluated? A track expression is
accompanied by an <em>iterator</em> that determines a set of intervals
over which the expression iterator goes. For each each iterator interval
the track expression is evaluated. The value of a track expression
<code>"mean(1:10)"</code> is constant regardless the iterator interval.
However suppose the track expression contains a track name
<code>mytrack</code>, like: <code>"mytrack * 3"</code>, and the whole
story becomes very different. The library first recognizes that
<code>mytrack</code> is not a regular R variable but rather a track
name. A new R variable named <code>mytrack</code> is added then to R
environment. For each iterator interval this variable is assigned the
corresponding value of the track. This value obviously depends on the
iterator interval. Once <code>mytrack</code> is assigned the
corresponding value, the track expression is evaluated in R.</p>
<p>So how exactly the value of <code>mytrack</code> variable is
determined given the iterator interval? We will demonstrate the answer
by the following example. Suppose the track <code>mytrack</code> is in
sparse format. It consists of a single chromosome with the following
values:</p>
<table class="table">
<thead><tr class="header">
<th>chrom</th>
<th>start</th>
<th>end</th>
<th>value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>chr1</td>
<td>100</td>
<td>200</td>
<td>10</td>
</tr>
<tr class="even">
<td>chr1</td>
<td>200</td>
<td>250</td>
<td>25</td>
</tr>
<tr class="odd">
<td>chr1</td>
<td>500</td>
<td>560</td>
<td>17</td>
</tr>
<tr class="even">
<td>chr1</td>
<td>600</td>
<td>700</td>
<td>44</td>
</tr>
</tbody>
</table>
<p>What would be the value of the variable <code>mytrack</code> given an
iterator interval? The resulted value is an average of all values of
track <code>mytrack</code> covered by the iterator interval. For
example, if the iterator interval is <code>[230, 620)</code> then the
resulted value is an average of values 25, 17 and 44. Similarly if the
iterator interval is <code>[0, 300)</code> then the resulted value is an
average of 10 and 25. Lastly if the iterator intervals is
<code>[300, 400)</code> then the resulted value is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math>.
Same evaluation logics is applied for Dense and Array tracks. (In the
latter case the values from all columns are averaged.) On contrary
Rectangles track value is calculated as a <em>weighted</em> average of
the values covered by the iterator interval. The weight equals to the
intersection area of the iterator interval and the 2D interval that
contains the value.</p>
<p>See the table below:</p>
<table class="table">
<colgroup>
<col width="65%">
<col width="35%">
</colgroup>
<thead><tr class="header">
<th>Track Type</th>
<th>Value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Dense</td>
<td>Average of non
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math>
values covered by iterator interval.</td>
</tr>
<tr class="even">
<td>Sparse</td>
<td>Average of non
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math>
values covered by iterator interval.</td>
</tr>
<tr class="odd">
<td>Array</td>
<td>Average of non
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math>
values from all columns covered by iterator interval.</td>
</tr>
<tr class="even">
<td>Rectangles</td>
<td>Weighted average of non
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math>
values covered by iterator interval. Each weight equals to the
intersection area between iterator interval and track interval that
contains the value.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="virtual-tracks">Virtual Tracks<a class="anchor" aria-label="anchor" href="#virtual-tracks"></a>
</h4>
<p>So far we showed that the value of a <code>mytrack</code> variable is
set to be the average (or weighted average) of the track values that are
covered by the iterator interval. But what if we do not want to average
the values but rather pick up the maximal or minimal values? What if we
want to use the percentile of a track value rather than the value
itself? And maybe we even want to alter the iterator interval itself on
the fly? This is where virtual tracks become useful.</p>
<p>Virtual track is a set of rules that describe how the “source” (a
real track, intervals, or a value-based track) should be proceeded, and
how the iterator interval should be modified. Virtual tracks are created
with <code>gvtrack.create</code> function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="st">"dense_track"</span><span class="op">)</span></span></code></pre></div>
<p>This call creates a new virtual track named <code>myvtrack</code>.
This virtual track can be used in the track expression instead of a real
track <code>dense_track</code>. In our example <code>myvtrack</code> is
just an alias of <code>dense_track</code>. Yet we can go on and create a
more complicated virtual track if we specify a “function”, i.e. instruct
the virtual track of what should be its value in track expression.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="st">"dense_track"</span>, <span class="st">"global.percentile"</span><span class="op">)</span></span></code></pre></div>
<p>In this example when <code>myvtrack</code> is evaluated in the track
expression it will return the percentile of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><annotation encoding="application/x-tex">V_{avg}</annotation></semantics></math>
among the values of <code>dense_track</code> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><annotation encoding="application/x-tex">V_{avg}</annotation></semantics></math>
is an average (or weighted average) of the track values that are covered
by the iterator interval.</p>
<p>Virtual tracks are especially useful for Array tracks. By default if
an Array track is used in a track expressions, its interval value would
be the average of all non-NaN column values covered by an iterator
interval. <code>gvtrack.array.slice</code> allows to select specific
columns and to specify the function applied to the values of each track
interval.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="st">"array_track"</span>, <span class="st">"sum"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gvtrack.array.slice.html">gvtrack.array.slice</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"col2"</span>, <span class="st">"col5"</span><span class="op">)</span>, <span class="st">"max"</span><span class="op">)</span></span></code></pre></div>
<p>In this example we create a virtual track based on
<code>array_track</code>. Assume that an iterator interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
covers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
different intervals in <code>array_track</code>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_0, ..., I_n</annotation></semantics></math>.
The value of <code>myvtrack</code> in a track expression would be then:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>V</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><msub><mi>V</mi><mrow><mi>i</mi><mo>,</mo><mn>5</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \sum_{i=1}^{n}max(V_{i,2}, V_{i,5}) </annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">V_{i,j}</annotation></semantics></math>
is a value of the track in column
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
for interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>i</mi></msub><annotation encoding="application/x-tex">I_i</annotation></semantics></math>.</p>
<p>Virtual tracks allow also to alter the iterator interval “on the
fly”:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.iterator.html">gvtrack.iterator</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, sshift <span class="op">=</span> <span class="op">-</span><span class="fl">100</span>, eshift <span class="op">=</span> <span class="fl">200</span><span class="op">)</span></span></code></pre></div>
<p>In this example we expand each iterator interval by adding -100 to
its <code>start</code> coordinate and 200 to its <code>end</code>
coordinate.</p>
<p>Similarly, iterator modifiers can be defined for 2D intervals.
Moreover, an iterator modifier can create a 1D interval from a 2D
iterator interval by projecting one of its axes.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="st">"dense_track"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gvtrack.iterator.html">gvtrack.iterator</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, dim <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>It is important to remember that iterator modifiers transform the
iterator interval only for the given virtual tracks. Assume an iterator
interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
and two virtual tracks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>0</mn></msub><annotation encoding="application/x-tex">V_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>1</mn></msub><annotation encoding="application/x-tex">V_1</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
is a 2D interval then <em>band</em> rules are applied first to it.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
is transformed then to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mn>0</mn></msub><annotation encoding="application/x-tex">I_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mn>1</mn></msub><annotation encoding="application/x-tex">I_1</annotation></semantics></math>
according to the modification rules defined by the virtual tracks.
Finally,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mn>0</mn></msub><annotation encoding="application/x-tex">I_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mn>1</mn></msub><annotation encoding="application/x-tex">I_1</annotation></semantics></math>
are passed to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>0</mn></msub><annotation encoding="application/x-tex">V_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mn>1</mn></msub><annotation encoding="application/x-tex">V_1</annotation></semantics></math>
accordingly as the iterator intervals.</p>
<p>So far we have used a track <code>dense_track</code> as a “source” of
a virtual track. We can also use intervals as a source. In this case,
the value of the virtual track will be some function that takes into
account the “source” intervals and the current iterator interval.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="st">"annotations"</span>, <span class="st">"distance"</span><span class="op">)</span></span>
<span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gscreen.html">gscreen</a></span><span class="op">(</span><span class="st">"dense_track &gt; 0.45"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gextract.html">gextract</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="va">.misha</span><span class="op">$</span><span class="va">ALLGENOME</span>, iterator <span class="op">=</span> <span class="va">intervs</span><span class="op">)</span></span></code></pre></div>
<p>In this example <code>myvtrack</code> returns the minimal distance
between intervals from an interval set <code>annotations</code> and the
center of the current iterator interval from <code>intervs</code>.</p>
<div class="section level5">
<h5 id="value-based-tracks">Value-Based Tracks<a class="anchor" aria-label="anchor" href="#value-based-tracks"></a>
</h5>
<p>In addition to using database tracks and interval sets as sources,
virtual tracks can also use <strong>value-based tracks</strong> as
sources. Value-based tracks are data frames containing genomic intervals
with associated numeric values. They function as in-memory sparse tracks
without requiring track creation in the database.</p>
<p>To create a value-based virtual track, provide a data frame with
columns <code>chrom</code>, <code>start</code>, <code>end</code>, and
one numeric value column (any column name is acceptable):</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create a data frame with intervals and numeric values</span></span>
<span><span class="va">intervals_with_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    chrom <span class="op">=</span> <span class="st">"chr1"</span>,</span>
<span>    start <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">300</span>, <span class="fl">500</span><span class="op">)</span>,</span>
<span>    end <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">400</span>, <span class="fl">600</span><span class="op">)</span>,</span>
<span>    score <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use as value-based sparse track</span></span>
<span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack"</span>, <span class="va">intervals_with_values</span>, <span class="st">"avg"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gvtrack.create.html">gvtrack.create</a></span><span class="op">(</span><span class="st">"myvtrack_max"</span>, <span class="va">intervals_with_values</span>, <span class="st">"max"</span><span class="op">)</span></span></code></pre></div>
<p>Value-based tracks support all track-based summarizer functions
(e.g., <code>avg</code>, <code>min</code>, <code>max</code>,
<code>sum</code>, <code>stddev</code>, <code>quantile</code>,
<code>nearest</code>, <code>exists</code>, <code>size</code>,
<code>first</code>, <code>last</code>, <code>sample</code>, and position
functions). However, they have one important restriction:
<strong>intervals must not overlap</strong>. Unlike interval-based
summarizers (which work with overlapping intervals), value-based tracks
behave like sparse tracks and require non-overlapping intervals.</p>
<p>Value-based tracks aggregate values using count-based averaging (each
interval contributes equally regardless of length), matching the
behavior of sparse tracks. This means when multiple intervals are
covered by an iterator interval, each interval’s value contributes
equally to the aggregation, regardless of the interval’s length.</p>
<p>For a full list of supported functions please see
<code>gvtrack.create</code> and <code>gvtrack.array.slice</code>
functions.</p>
</div>
</div>
<div class="section level4">
<h4 id="administrating-virtual-tracks">Administrating Virtual Tracks<a class="anchor" aria-label="anchor" href="#administrating-virtual-tracks"></a>
</h4>
<p>As described in the previous chapter virtual tracks define a set of
rules of how to access and proceed the values of the “source” object.
The connection between the virtual track and the source object is done
via “soft link”, i.e. by name and not by reference. For example, a
virtual track will continue to exist until explicitly removed by
<code>gvtrack.rm</code> even if the physical track that it is pointing
to is deleted or renamed.</p>
<p>Operations such as <code>gdb.init</code> and <code>gdir.cd</code>
alter the list of available tracks and intervals sets. Since these
objects are referenced by virtual tracks, these latter are always
defined in the context of the current working directory in Genomic
Database (not to be confused with shell’s current working directory).
Changing the current working directory using <code>gdb.init</code> or
<code>gdir.cd</code> will also change the list of available virtual
tracks.</p>
<p>Another issue to bare in mind is that unlike regular tracks whose
data is stored on disk virtual tracks are non-persistent objects in
current R environment. Their definition is stored in
<code>GVTRACKS</code> R variable. In particular a virtual track named
“vtrack” that was created within a context of “/home/user/trackdb”
Genomic Database working directory would reside in
<code>GVTRACKS[["/home/user/trackdb"]][["vtrack"]]</code>. One can also
use <code>gvtrack.info</code> function that provides a more convenient
access to virtual track definitions.</p>
<p>As the virtual tracks are stored in an R variable their behavior
hence complies with the rules of other R variables: a virtual track
defined by one user will not be seen by another one, virtual tracks
might disappear once R is relaunched, etc.</p>
<p>To preserve the definition of virtual tracks between the sessions one
would need to save <code>GVTRACKS</code> variable on disk. The
serialization of <code>GVTRACKS</code> is under user’s responsibility.
The standard suit of functions for saving / loading R variables can be
used for that purpose.</p>
<p>Note that if <code>GVTRACKS</code> is loaded from a file or changed
manually by a user the <em>auto-completion</em> list (in case it is
turned on) might need to be refreshed by calling
<code>gdb.reload</code>.</p>
</div>
<div class="section level4">
<h4 id="track-expression-evaluation-under-optimization">Track Expression Evaluation under Optimization<a class="anchor" aria-label="anchor" href="#track-expression-evaluation-under-optimization"></a>
</h4>
<p>Previously we described how a track expression
<code>"mytrack * 3"</code> (where <code>mytrack</code> is a track name)
leads to an implicit definition of <code>mytrack</code> variable in R
environment. To make our explanation easier we presented this variable
as a scalar whose value is altered each time the iterator interval
changes. It’s time to admit that that was oversimplification. In reality
the library defines <code>mytrack</code> variable as a vector (i.e. an
array) and not as a single scalar. The vector is filled then with the
corresponding values of the track. Finally the track expression is
evaluated in R and the result is expected to be also a vector of the
same size as <code>mytrack</code> vector. Working with vectors rather
than single scalars reduces the number of evaluations within R and hence
improves run-times.</p>
<p>The size of the vector is controlled via <code>gbuf.size</code>
option. By default it equals to 1000. Altering this value (for instance
setting it to 1) might significantly affect the run-time of various
functions in the library. If you still wish to force the functions to
define scalars rather than vectors, set <code>gbuf.size</code> to 1:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>gbuf.size <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>One might wonder why should we care about the fact that
<code>mytrack</code> is not a scalar but rather a vector? Indeed in many
cases it does not really matter. For example <code>mytrack * 3</code>
expression produces exactly the same results regardless whether
<code>mytrack</code> is defined internally as a vector or as a scalar.
This is due to the fact that the expression <code>V * 3</code>
(<code>V</code> stands for a vector) results in each value of
<code>V</code> being multiplied by 3.</p>
<p>Multiplication is a good example of “parallel” operation in R (works
on each element in vector separately). On contrary some functions that
accept a vector might return a scalar rather than a vector. Such is, for
example, <code>min</code> function.</p>
<p>Let’s look at the following track expression:
<code>track1 + min(track1, track2)</code>. This expression was probably
meant to produce a sum of <code>track1</code> track and a minimum value
between <code>track1</code> and <code>track2</code> tracks for each
iterator interval. However the library defines the variables
<code>track1</code> and <code>track2</code> to be vectors of
<code>gbuf.size</code> size (by default: 1000). <code>min</code> is not
a “parallel” operation. Given two vectors of any size it returns a
single scalar that is the minimal value of <em>all</em> values in both
of the vectors. Therefore <code>track1 + min(track1, track2)</code> will
be interpreted as <code>track1 + M</code>, where M is minimum of 2000
values (1000 values from <code>track1</code> track, and another 1000 -
from <code>track2</code> track). We can hardly imagine that a user would
have really meant this! Sadly enough the expression will be seamlessly
evaluated and produce a valid, but meaningless result. The solution for
our example is to use <code>pmin</code> rather than <code>min</code>
function.</p>
<p>The library always verifies that the evaluation of the track
expression produces a vector of the same size as the size of a track
variable. In many cases this procedure is able to reveal faulty track
expressions. Yet in more tricky examples like the one that we used
before the library will not warn the user.</p>
<blockquote>
<p>Make sure your track expressions work correctly on vectors!</p>
</blockquote>
</div>
<div class="section level4">
<h4 id="revealing-current-iterator-interval">Revealing Current Iterator Interval<a class="anchor" aria-label="anchor" href="#revealing-current-iterator-interval"></a>
</h4>
<p>During the evaluation of a track expression one can access a
specially defined variable named <code>GITERATOR.INTERVALS</code>. This
variable contains a set of iterator intervals for which the track
expression is evaluated. <code>GITERATOR.INTERVALS</code> contains the
same number of intervals as the size of <code>mytrack</code> vector from
our previous example. The value of a track <code>mytrack</code> for an
interval <code>i</code> is stored at <code>mytrack[i]</code>.</p>
<p>Note that some intervals in <code>GITERATOR.INTERVALS</code> might
have a start coordinate equal to -1. Skip those intervals and the values
of <code>mytrack</code> at the corresponding index.</p>
</div>
<div class="section level4">
<h4 id="iterators">Iterators<a class="anchor" aria-label="anchor" href="#iterators"></a>
</h4>
<p>So far we have discussed in details how the track expression is
evaluated given the <em>iterator interval</em>. Yet how the iterator
intervals can be controlled?</p>
<p>Most of the functions that accept track expressions have an
additional parameter named <code>iterator</code>. The value of this
parameter determines the iterator intervals which is also sometimes
called an <em>iterator policy</em>:</p>
<table class="table">
<colgroup>
<col width="13%">
<col width="10%">
<col width="19%">
<col width="57%">
</colgroup>
<thead><tr class="header">
<th>Value</th>
<th>Iterator Policy Type</th>
<th>Example</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Integer</td>
<td>Fixed Bin</td>
<td><code>50</code></td>
<td>Iterator intervals will advance by a fixed step (bin) starting from
zero coordinate up to chromosome’s length:
<code>[0,50), [50,100), [100,150), ...</code>
</td>
</tr>
<tr class="even">
<td>Dense track</td>
<td>Fixed Bin</td>
<td><code>"dense_track"</code></td>
<td>Use the bin size of the track as a fixed step.</td>
</tr>
<tr class="odd">
<td>1D intervals</td>
<td>1D Intervals</td>
<td><code>"annotations"</code></td>
<td>Iterate over the supplied intervals. <em>Note: the intervals are
sorted and overlapping intervals are unified.</em>
</td>
</tr>
<tr class="even">
<td>Sparse track</td>
<td>1D Intervals</td>
<td><code>"sparse_track"</code></td>
<td>Iterate over the intervals of a sparse track.</td>
</tr>
<tr class="odd">
<td>Array track</td>
<td>1D Intervals</td>
<td><code>"array_track"</code></td>
<td>Iterate over the intervals of an array track.</td>
</tr>
<tr class="even">
<td>c(integer, integer)</td>
<td>2D Intervals</td>
<td><code>c(1000, 2000)</code></td>
<td>2D iterator intervals will cover the whole 2D chromosomal space by
rectangles of fixed size: Width X Height. Please keep in mind that small
rectangles used without a limiting scope might result in immense number
of iterator intervals.</td>
</tr>
<tr class="odd">
<td>2D intervals</td>
<td>2D Intervals</td>
<td><code>gintervals.2d(c(1, 2))</code></td>
<td>Iterate over the supplied intervals. <em>Note: the intervals are
sorted and overlapping is forbidden.</em>
</td>
</tr>
<tr class="even">
<td>Rectangles track</td>
<td>2D Intervals</td>
<td><code>"rects_track"</code></td>
<td>Iterate over the intervals of a Rectangles track</td>
</tr>
<tr class="odd">
<td>Cartesian grid iterator</td>
<td>2D Intervals</td>
<td><code>giterator.cartesian_grid( intervals1, intervals2, c(10, 20, 30))</code></td>
<td>Iterate over 2D cartesian grid (see
<code>giterator.cartesian_grid</code> function)</td>
</tr>
<tr class="even">
<td>NULL</td>
<td>Fixed Bin OR 1D Intervals OR 2D Intervals</td>
<td>NULL</td>
<td>Implicitly determine the iterator policy based on the tracks that
appear in the track expression. If no track names presented or two
different tracks determine different iterator policy, an error is
reported.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="scope">Scope<a class="anchor" aria-label="anchor" href="#scope"></a>
</h4>
<p>Many functions that accept a track expressions and iterator policy
accept an additional set of intervals that limit the scope of a
function. This scope also limits the iterator intervals. For
instance:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/gextract.html">gextract</a></span><span class="op">(</span><span class="st">"dense_track"</span>, <span class="fu"><a href="../reference/gintervals.html">gintervals</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">340</span>, <span class="fl">520</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>As one can notice the first and the last intervals in the result are
truncated by the scope <code>[340, 520)</code>.</p>
<p>In some cases the combination of iterator policy and scope might
result in nontrivial set of iterator intervals. Use
<code>giterator.intervals</code> function to retrieve the iterator
intervals given a track expression, scope and an iterator.</p>
</div>
<div class="section level4">
<h4 id="band">Band<a class="anchor" aria-label="anchor" href="#band"></a>
</h4>
<p>As explained before track expression iterator can be determined
implicitly or through an <code>iterator</code> parameter. In either case
the result is a set of 1D or 2D intervals depending on how the iterator
was defined. If iterator intervals are 2D an additional filter can be
applied to them: a <em>band</em>.</p>
<p>A band is a pair of integers:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_1, D_2</annotation></semantics></math>.
We say that a 2D iterator interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(chrom_1, x_1, x_2, chrom_2, y_1, y_2)</annotation></semantics></math>
intersects a band if and only if the next two conditions are true:</p>
<ol style="list-style-type: decimal">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>1</mn></msub><mo>=</mo><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">chrom_1 = chrom_2</annotation></semantics></math></li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>:</mo><msub><mi>x</mi><mn>1</mn></msub><mo>≤</mo><mi>x</mi><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>y</mi><mn>1</mn></msub><mo>≤</mo><mi>y</mi><mo>&lt;</mo><msub><mi>y</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>1</mn></msub><mo>≤</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo>&lt;</mo><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\exists x,y: x_1 \le x &lt; x_2 \wedge y_1 \le y &lt; y_2 \wedge D_1 \le x-y &lt; D_2</annotation></semantics></math>.</li>
</ol>
<p>In a less formal way we can see a band as a space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
between two 45-degrees diagonals where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mn>1</mn><mo>,</mo><mi>D</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">D1, D2</annotation></semantics></math>
determine where these diagonals cross
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
axis. An iterator interval represents a rectangle in a 2D space and can
be therefore intersected with S. The result of the intersection can be a
rectangle, a trapeze, a triangle, a hexagon or it can be empty if the
interval does not intersect with the band. If the intersection is non
empty, the resulted figure, whatever it is, can be bound by some larger
rectangle. The rectangle that has the minimal space and yet containing
the intersected shape is called <em>the minimal rectangle</em>.</p>
<p>After the formal definitions it’s time to say how band is actually
applied.</p>
<p>If the intersection between the 2D iterator interval and the band is
non-empty and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>1</mn></msub><mo>=</mo><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">chrom_1=chrom_2</annotation></semantics></math>,
the minimal rectangle replaces the original iterator interval. Otherwise
the iterator interval is skipped as it lies outside of the band or the
two chromosomes are not equal.</p>
<p>The <code>gintervals.2d.band_intersect</code> function can help one
better understand the concept:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">200</span>, <span class="fl">800</span>, <span class="fl">1</span>, <span class="fl">100</span>, <span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">intervs</span>, <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">900</span>, <span class="fl">950</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">intervs</span>, <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">100</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">400</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">intervs</span>, <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">900</span>, <span class="fl">950</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">intervs</span></span></code></pre></div>
<p><code>gintervals.2d.band_intersect</code> intersects the intervals
with the band and returns the intervals shrunk to the minimal rectangle.
As you can see we have four different intervals. The first one
<code>(chr1, 200, 800, chr1, 100, 1000)</code> intersects the band and
after shrinking to the minimal rectangle it becomes
<code>(chr1, 600, 800, chr1, 100, 300)</code>. The second interval lies
entirely within the band and hence is returned without any change. The
third interval lies entirely outside of the band, and hence is
eliminated from the result. The last interval is coming from two
different chromosomes and therefore is also filtered out.</p>
<p>As said band filters out and alters 2D iterator intervals. Yet it
also affects the result of 2D tracks. Let’s look at the following
example:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">intervs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">400</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">300</span>, <span class="fl">490</span><span class="op">)</span>, <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">120</span>, <span class="fl">180</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">500</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gtrack.2d.create.html">gtrack.2d.create</a></span><span class="op">(</span><span class="st">"test2d"</span>, <span class="st">"test 2D track"</span>, <span class="va">intervs</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gextract.html">gextract</a></span><span class="op">(</span><span class="st">"test2d"</span>, <span class="va">.misha</span><span class="op">$</span><span class="va">ALLGENOME</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gextract.html">gextract</a></span><span class="op">(</span><span class="st">"test2d"</span>, <span class="va">.misha</span><span class="op">$</span><span class="va">ALLGENOME</span>, iterator <span class="op">=</span> <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1000</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gintervals.2d.band_intersect.html">gintervals.2d.band_intersect</a></span><span class="op">(</span><span class="va">intervs</span>, band <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">150</span>, <span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gextract.html">gextract</a></span><span class="op">(</span><span class="st">"test2d"</span>, <span class="va">.misha</span><span class="op">$</span><span class="va">ALLGENOME</span>, iterator <span class="op">=</span> <span class="fu"><a href="../reference/gintervals.2d.html">gintervals.2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1000</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1000</span><span class="op">)</span>, band <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">150</span>, <span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/gtrack.rm.html">gtrack.rm</a></span><span class="op">(</span><span class="st">"test2d"</span>, force <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>We created a 2D track <code>test2d</code> and inserted two values
into it:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>10</mn><annotation encoding="application/x-tex">10</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>20</mn><annotation encoding="application/x-tex">20</annotation></semantics></math>.
If an iterator interval covers all the track’s rectangles, the resulted
value of the track would be a weighted average of its values where the
weight is equal to the intersected area. In our example it is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16.42857</mn><annotation encoding="application/x-tex">16.42857</annotation></semantics></math>.</p>
<p>We added a band then. <code>gintervals.2d.band_intersect</code> shows
the minimal rectangles: the intersection result of the original
rectangles with the band. The output of the new <code>gextract</code>
has been changed accordingly: the new weights in the weighted average
are equal to the new and smaller intersected area. The value has changed
therefore to:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>19.57182</mn><annotation encoding="application/x-tex">19.57182</annotation></semantics></math>.</p>
<blockquote>
<p>Note, however, that the space used in the calculation of the weighted
average is the actual space of the intersection and not the space
occupied by the minimal rectangles!</p>
</blockquote>
</div>
</div>
<div class="section level3">
<h3 id="random-algorithms">Random Algorithms<a class="anchor" aria-label="anchor" href="#random-algorithms"></a>
</h3>
<p>Various functions in the library such as <code>gsample</code> make
use of pseudo-random number generator. Each time the function is invoked
a unique series of random numbers is issued. Hence two identical calls
might produce different results. To guarantee reproducible results call
<code>set.seed</code> before invoking the function.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">60427</span><span class="op">)</span></span>
<span><span class="va">r1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gsample.html">gsample</a></span><span class="op">(</span><span class="st">"dense_track"</span>, <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">r2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gsample.html">gsample</a></span><span class="op">(</span><span class="st">"dense_track"</span>, <span class="fl">10</span><span class="op">)</span> <span class="co"># r2 differs from r1</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">60427</span><span class="op">)</span></span>
<span><span class="va">r3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gsample.html">gsample</a></span><span class="op">(</span><span class="st">"dense_track"</span>, <span class="fl">10</span><span class="op">)</span> <span class="co"># r3 == r1</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="multitasking">Multitasking<a class="anchor" aria-label="anchor" href="#multitasking"></a>
</h3>
<div class="section level4">
<h4 id="controlling-the-number-of-processes">Controlling the Number of Processes<a class="anchor" aria-label="anchor" href="#controlling-the-number-of-processes"></a>
</h4>
<p>To boost the run time performance various functions in the library
support multitasking mode, i.e. parallel computation of the result by
several concurrent processes. The exact number of processes internally
launched depends on the specific call however the upper bound can be
controlled by a few parameters such as <code>gmax.processes</code>
(absolute upper bound), <code>gmax.processes2core</code> (maximal number
of processes per CPU core) and <code>gmin.scope4process</code> (minimal
scope range / surface assigned to a process). Multitasking can also be
completely switched off by setting <code>gmultitasking</code> parameter
to <code>FALSE</code>.</p>
</div>
<div class="section level4">
<h4 id="auto-configuration">Auto-Configuration<a class="anchor" aria-label="anchor" href="#auto-configuration"></a>
</h4>
<p>The <code>misha</code> package automatically configures itself based
on your system’s resources when loaded. This happens transparently
without any user intervention:</p>
<p><strong>Automatic Process Limits:</strong> The package detects the
number of CPU cores and sets <code>gmax.processes = 70% of cores</code>.
This ensures optimal parallelism while leaving headroom for the system.
For example: - On a 4-core laptop: <code>gmax.processes = 2</code> (70%
of 4) - On a 16-core workstation: <code>gmax.processes = 11</code> (70%
of 16) - On a 128-core server: <code>gmax.processes = 89</code> (70% of
128)</p>
<p><strong>Automatic Buffer Size:</strong> The package coordinates
buffer size with process limits to ensure
<code>gmax.processes * gmax.data.size &lt;= 70% of RAM</code>.
Specifically, it sets
<code>gmax.data.size = min((RAM * 0.7) / gmax.processes, 10GB)</code>.
This ensures that when all processes are running at full capacity, total
memory usage stays within safe limits. For example: - On a 4-core, 8GB
laptop: <code>gmax.processes = 2</code>,
<code>gmax.data.size = 2.8GB</code> (total: 5.6GB = 70% of 8GB) - On a
16-core, 32GB workstation: <code>gmax.processes = 11</code>,
<code>gmax.data.size = 2.0GB</code> (total: 22.4GB = 70% of 32GB) - On a
128-core, 256GB server: <code>gmax.processes = 89</code>,
<code>gmax.data.size = 2.0GB</code> (total: 179.2GB = 70% of 256GB)</p>
<p>The 10GB cap is empirically determined - larger shared memory
allocations can fail even when system limits appear to allow them. This
cap is rarely hit on multi-core systems due to the per-process
division.</p>
<p><strong>Automatic Small Dataset Detection:</strong> The package
automatically detects small datasets and uses single-threaded mode to
avoid fork overhead. The threshold scales with your system:
<code>threshold = gmax.processes * 1000 records</code>. For example: -
4-core laptop (2 procs): single-threaded below 2K records - 16-core
workstation (11 procs): single-threaded below 11K records - 128-core
server (89 procs): single-threaded below 89K records</p>
<p>This dynamic threshold ensures fork overhead stays below 10% of
runtime. For larger datasets, multitasking is automatically enabled when
beneficial.</p>
<p><strong>Manual Override:</strong> You can still manually set these
options if needed:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>gmax.processes <span class="op">=</span> <span class="fl">32</span><span class="op">)</span>        <span class="co"># Override process limit</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>gmax.data.size <span class="op">=</span> <span class="fl">5e9</span><span class="op">)</span>       <span class="co"># Override buffer size (5GB)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>gmultitasking <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span>      <span class="co"># Disable multitasking entirely</span></span></code></pre></div>
<p>To check current auto-configured values:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">getOption</a></span><span class="op">(</span><span class="st">"gmax.processes"</span><span class="op">)</span>         <span class="co"># Current process limit</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">getOption</a></span><span class="op">(</span><span class="st">"gmax.data.size"</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1e9</span>   <span class="co"># Current buffer size in GB</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="limiting-the-memory-consumption">Limiting the Memory Consumption<a class="anchor" aria-label="anchor" href="#limiting-the-memory-consumption"></a>
</h4>
<p>For certain functions multitasking might result in higher memory
consumption. Users who have per process virtual memory limit (see:
<code>ulimit -v</code>) might be the first to suffer from memory
allocation errors.</p>
<p>Various factors can affect the memory usage such as the number of
running processes used for parallel computation, the value of
<code>gmax.data.size</code> option or the combination of both. Some of
the functions such as <code>gscreen</code> or <code>gextract</code>
consume in multitasking mode amount of memory proportional to
<code>gmax.data.size</code>. Please be aware of it while altering the
value of this option.</p>
<p>To limit memory consumption in multitasking mode one might lower down
the values of <code>gmax.data.size</code> and
<code>gmax.mem.usage</code> options or even switch off multitasking mode
completely. <code>gmax.mem.usage</code> indicates the upper limit in KB
of memory consumed cumulatively by the child processes. Once this limit
is breached an internal mechanism tries to pause some of the running
child processes, thereby preventing them from allocating more memory.
The paused processes are resumed once the memory consumption drops or
other sibling processes end.</p>
<p>One should not expect the internal limiting mechanism to be the
panacea for memory hungry tasks. First, the memory consumption of some
of the functions is proportional to <code>gmax.data.size</code> option
regardless of the number of running processes. Second, even when the
memory limit is exceeded at least one process is still left to run and
to potentially increase the memory consumption further. Third, the
mechanism is mainly periodic, i.e. excessive memory consumption is
detected only once in a while. The decision to pause running processes
is thus periodic as well. The memory that has already been consumed in
the time gap between the checks will not be release up until the whole
task is complete.</p>
<p>It is worth to say a word about memory consumption. Deducting real
memory usage of the process based on “top”, “ps” or other utilities of
similar kind might be highly misleading. Since all the processes are
spawned from R, their memory usage as reported by these utilities will
be at least as high as that of their parent process. If, for example, R
process uses 5 Gb of memory and 10 processes are spawned from it, the
virtual memory of all these 11 processes will top 55 Gb. Yet the
majority of the consumed memory will be shared and unless the child
processes start modifying this memory or allocating new one, the
physical free memory of the machine will remain almost unaltered. The
internal memory consumption limiting mechanism tries to estimate the
drop of system free memory and hence deducts its data from counting
“Private Dirty” bytes (on Linux) or from internal estimation (on other
platforms) - a very different datum from what “top” is reporting.</p>
</div>
<div class="section level4">
<h4 id="other-considerations">Other Considerations<a class="anchor" aria-label="anchor" href="#other-considerations"></a>
</h4>
<p>In multitasking mode the return value of <code>gquantiles</code> may
vary depending on the number of CPU cores. For more details please refer
the documentation of this function.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Misha Hoichman, Aviezer Lifshitz, Eitan Yaffe, Amos Tanay.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

      </footer>
</div>






  </body>
</html>
