% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/track.R
\name{gtrack.liftover}
\alias{gtrack.liftover}
\title{Imports a track from another assembly}
\usage{
gtrack.liftover(
  track = NULL,
  description = NULL,
  src.track.dir = NULL,
  chain = NULL,
  src_overlap_policy = "error",
  tgt_overlap_policy = "auto",
  multi_target_agg = c("mean", "median", "sum", "min", "max", "count", "first", "last",
    "nth", "max.coverage_len", "min.coverage_len", "max.coverage_frac",
    "min.coverage_frac"),
  params = NULL,
  na.rm = TRUE,
  min_n = NULL
)
}
\arguments{
\item{track}{name of a created track}

\item{description}{a character string description}

\item{src.track.dir}{path to the directory of the source track}

\item{chain}{name of chain file or data frame with 8 columns as returned by
'gintervals.load_chain' (chrom, start, end, strand, chromsrc, startsrc, endsrc, strandsrc).
Strand columns use +1 for forward strand and -1 for reverse strand.}

\item{src_overlap_policy}{policy for handling source overlaps: "error" (default), "keep", or "discard". "keep" allows one source interval to map to multiple target intervals, "discard" discards all source intervals that have overlaps and "error" throws an error if source overlaps are detected.}

\item{tgt_overlap_policy}{policy for handling target overlaps: "error", "auto" (default), "keep", or "discard". "auto" automatically resolves overlaps by truncating/splitting intervals, "keep" preserves overlapping target intervals, "discard" discards all target intervals that have overlaps and "error" throws an error if target overlaps are detected.}

\item{multi_target_agg}{aggregation/selection policy for contributors that land on the same target locus.
When multiple source intervals map to overlapping regions in the target genome (after applying tgt_overlap_policy),
their values must be combined into a single value. The following aggregation policies are supported:

\emph{"mean"} \cr Average of all contributor values.

\emph{"median"} \cr Median of all contributor values.

\emph{"sum"} \cr Sum of all contributor values.

\emph{"min"} \cr Minimum of all contributor values.

\emph{"max"} \cr Maximum of all contributor values.

\emph{"count"} \cr Number of contributors (ignoring NA values if na.rm=TRUE).

\emph{"first"} \cr Value from the contributor with the smallest start coordinate in the \emph{target} genome.
In case of ties (same start coordinate), the contributor with the smaller end coordinate is chosen.
If still tied, the larger value is chosen.

\emph{"last"} \cr Value from the contributor with the largest start coordinate in the \emph{target} genome.
In case of ties, the contributor with the larger end coordinate is chosen. If still tied, the larger value is chosen.

\emph{"nth"} \cr Value from the nth contributor when ordered by target genome position (smallest start, then smallest end, with ties broken by largest value).
Requires \code{params} to specify which contributor to select (1-based index).
For example, params=1 selects the first contributor, params=2 selects the second. Returns NA if there are fewer than n contributors.

\emph{"max.coverage_len"} \cr Value from the contributor with the longest overlap with the target locus (in base pairs).
In case of ties, the contributor with the larger value is chosen.

\emph{"min.coverage_len"} \cr Value from the contributor with the shortest overlap with the target locus (in base pairs).
In case of ties, the contributor with the larger value is chosen.

\emph{"max.coverage_frac"} \cr Value from the contributor with the highest coverage fraction
(overlap length / source interval length). In case of ties, the contributor with the larger value is chosen.

\emph{"min.coverage_frac"} \cr Value from the contributor with the lowest coverage fraction
(overlap length / source interval length). In case of ties, the contributor with the larger value is chosen.}

\item{params}{optional list or scalar with aggregator-specific parameters.
Currently only the "nth" aggregator uses this parameter. It expects either a scalar (e.g., params=2)
or a list with an 'n' element (e.g., params=list(n=2)) specifying the 1-based index of the contributor to select.}

\item{na.rm}{logical flag controlling NA removal prior to aggregation. If TRUE (default), NA values are ignored
during aggregation. If FALSE, the presence of any NA value causes the aggregated result to be NA.
This applies to all aggregators except "count", which always ignores NAs when counting.}

\item{min_n}{optional minimum number of non-NA contributors required to produce a non-NA result.
If specified and the number of non-NA contributors is less than min_n, the result will be NA.
If NULL (default), no minimum is enforced. This parameter works in conjunction with na.rm:
if na.rm=FALSE, a single NA contributor will cause the result to be NA regardless of min_n.}
}
\value{
None.
}
\description{
Imports a track from another assembly.
}
\details{
This function imports a track located in 'src.track.dir' of another assembly
to the current database. Chain file instructs how the conversion of
coordinates should be done. It can be either a name of a chain file or a
data frame in the same format as returned by 'gintervals.load_chain'
function. The name of the newly created track is specified by 'track'
argument and 'description' is added as a track attribute.

Source overlaps occur when the same source genome position maps to multiple
target genome positions. Using 'src_overlap_policy = "keep"' may result in
duplicated track values when one source position maps to multiple target
positions. Target overlaps occur when multiple source positions map to
overlapping regions in the target genome.

When passing a chain file path (as opposed to a pre-loaded chain data frame),
the policies are used both for loading the chain and performing the liftover.
When passing a pre-loaded chain data frame, the policies only apply to the
liftover operation itself.
}
\note{
Terminology note for UCSC chain format users: In the UCSC chain format specification,
the fields prefixed with 't' (tName, tStart, tEnd, etc.) are called "target" or "reference",
while fields prefixed with 'q' (qName, qStart, qEnd, etc.) are called "query". However,
misha uses reversed terminology: UCSC's "target/reference" corresponds to misha's "source"
(chromsrc, startsrc, endsrc), and UCSC's "query" corresponds to misha's "target"
(chrom, start, end).
}
\seealso{
\code{\link{gintervals.load_chain}},
\code{\link{gintervals.liftover}}
}
\keyword{~chain}
\keyword{~liftover}
\keyword{~track}
