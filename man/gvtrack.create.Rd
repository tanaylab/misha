% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vtrack.R
\name{gvtrack.create}
\alias{gvtrack.create}
\title{Creates a new virtual track}
\usage{
gvtrack.create(vtrack = NULL, src = NULL, func = NULL, params = NULL, ...)
}
\arguments{
\item{vtrack}{virtual track name}

\item{src}{source (track/intervals). NULL for PWM functions}

\item{func}{function name (see above)}

\item{params}{function parameters (see above)}

\item{...}{additional PWM parameters}
}
\value{
None.
}
\description{
Creates a new virtual track.
}
\details{
This function creates a new virtual track named 'vtrack' with the given
source, function and parameters. 'src' can be either a track or intervals
(1D or 2D). Use the following table for a reference of all valid source,
function and parameters combinations:

\emph{src = [Track], func = "avg", params = NULL} \cr Average track value in
iterator interval.

\emph{src = [Track], func = "max", params = NULL} \cr Maximal track value in
iterator interval.

\emph{src = [Track], func = "min", params = NULL} \cr Minimal track value in
iterator interval.

\emph{src = ['Dense' / 'Sparse' / 'Array' track], func = "nearest", params =
NULL} \cr Mean track value in iterator interval. If there are no track
values covered by an iterator interator (can occur only in 'Sparse' track),
the nearest track value is returned.

\emph{src = ['Dense' / 'Sparse' / 'Array' track], func = "stddev", params =
NULL} \cr Unbiased standard deviation of track values in iterator interval.

\emph{src = ['Dense' / 'Sparse' / 'Array' track], func = "sum", params =
NULL} \cr Sum of track values in iterator interval.

\emph{src = ['Dense' / 'Sparse' / 'Array' track], func = "quantile", params
= [Percentile in the range of [0, 1]]} \cr Quantile of track values in
iterator interval.

\emph{src = ['Dense' track], func = "global.percentile", params = NULL} \cr
Percentile of an average track value in iterator interval relatively to all
values of the track.

\emph{src = ['Dense' track], func = "global.percentile.max", params = NULL}
\cr Percentile of a maximal track value in iterator interval relatively to
all values of the track.

\emph{src = ['Dense' track], func = "global.percentile.min", params = NULL}
\cr Percentile of a minimal track value in iterator interval relatively to
all values of the track.

\emph{src = [2D track], func = "area", params = NULL} \cr Area covered by
iterator interval.

\emph{src = [2D track], func = "weighted.sum", params = NULL} \cr Weighted
sum of values where each weight equals to the intersection area between the
iterator interval and the rectangle containing the value.

\emph{src = [1D intervals], func = "distance", params = [Minimal distance
from center (default: 0)]} \cr Given the center 'C' of the current iterator
interval returns 'DC * X/2', where 'DC' is the normalized distance to the
center of the interval that contains 'C', and 'X' is the value of the
parameter. If no interval contains 'C' the resulted value is 'D + XXX/2'
where 'D' is the distance between 'C' and the edge of the closest interval.
Distance can be positive or negative depending on the position of the
coordinate relative to the interval and the strand (-1 or 1) of the
interval. Distance is always positive if 'strand' is '0' or if 'strand'
column is missing. Distance is 'NA' if no intervals exist for the current
chromosome.

\emph{src = [1D intervals], func = "distance.center", params = NULL} \cr
Given the center 'C' of the current iterator interval returns 'NaN' if 'C'
is outside of the intervals, otherwise returns the distance between 'C' and
the center of the closest interval. Distance can be positive or negative
depending on the position of the coordinate relative to the interval and the
strand (-1 or 1) of the interval. Distance is always positive if 'strand' is
'0' or if 'strand' column is missing.

\emph{src = [1D intervals], func = "coverage", params = NULL} \cr
For each iterator interval, calculates the fraction of its length that is covered by the
source intervals. Returns a value between 0 and 1. For example, if an iterator interval is [100,200]
and the source intervals cover positions 120-140 and 160-170, the coverage would be 0.3
((20 + 10) / 100 = 0.3). Overlapping source intervals are first unified.

\emph{src = [1D intervals], func = "neighbor.count", params = [Max distance >= 0]} \cr
Returns, for each iterator interval, the number of source intervals whose edge-to-edge distance
to the iterator interval is <= params. Equivalent to counting overlaps with source intervals expanded
by params on both sides. Overlapping sources are NOT unified (multiplicity preserved).

\emph{func = "pwm", params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE, spat_factor = NULL, spat_bin = NULL,
spat_min = NULL, spat_max = NULL)} \cr
Calculates total log-likelihood score of DNA sequence against PSSM.
Uses log-sum-exp over all positions. For bidirect=TRUE, scans both strands and
combines them per genomic start position (a per-position union).
Prior adds pseudocounts. The extend=TRUE parameter (default) pads the fetched
sequence by extending the END coordinate by (motif_length-1) bases for all strand modes.
This allows motifs anchored inside the iterator to be evaluated even when they extend
beyond the iterator boundary. At genomic position i, we always need sequence [i, i+motif_len),
regardless of strand (reverse strand computes RC of the same genomic positions). Only motif
anchors whose 0-based start lies inside the iterator contribute; the extra sequence provides
context only. With extend=FALSE, only motifs fully contained within the interval are scored.
Optional spatial weighting allows position-dependent weights.

\emph{func = "pwm.max", params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE, spat_factor = NULL, spat_bin = NULL,
spat_min = NULL, spat_max = NULL)} \cr
Returns maximum log-likelihood score of best PSSM match.
When \code{bidirect=TRUE}, both strands are scanned and the reported value is the
\emph{single best-strand} score after spatial weightingâ€”the two strand scores are
compared, not summed. (This is a \emph{per-position union}, not per-strand accumulation.)
The \code{strand} parameter is ignored when \code{bidirect=TRUE}.
Prior adds pseudocounts. The \code{extend=TRUE} parameter (default) allows scoring
motifs whose start position falls within the interval, even if the motif extends
beyond the interval boundary. Neutral characters (\code{N}, \code{n}, \code{*} by default)
are scored with the mean log-probability of each PSSM column on both strands, so the
same penalty applies regardless of orientation.
Optional spatial weighting allows position-dependent weights.

\emph{func = "pwm.max.pos", params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE, spat_factor = NULL, spat_bin = NULL,
spat_min = NULL, spat_max = NULL)} \cr
Returns 1-based position of best PSSM match.
This position is 1-based relative to the start of the final scan window, which is determined after applying any iterator shifts (e.g., \code{sshift} from \code{\link{gvtrack.iterator}}) or the \code{spat_min} parameter. In case of ties, the position of the first match (most 5' / smallest coordinate) encountered during the scan is returned. The forward strand is checked before the reverse strand at each position, so it will win in a direct tie at the same location.
If bidirect=TRUE, the position would be positive if the best hit was at the
forward strand, and negative if it was at the reverse strand. When strand is
-1 the position is still according to the forward strand, but the hit is at
the end of the match.
Prior adds pseudocounts, extend=TRUE allows boundary scoring.
Optional spatial weighting allows position-dependent weights.

\emph{func = "pwm.count", params = list(pssm = matrix, score.thresh = 0,
bidirect = TRUE, prior = 0.01, extend = TRUE, strand = 1)} \cr
Counts motif hits with score >= threshold inside each interval.
For \code{bidirect=FALSE}, only the strand given by \code{strand} is checked.
For \code{bidirect=TRUE}, both strands are evaluated at each position and the
\emph{combined} score is tested against the threshold. The default combination is
log-sum-exp (LSE), consistent with \code{pwm}. Each position contributes at most 1
to the count (per-position union), not a per-strand sum.
Returns the total number of passing positions and only counts anchors whose genomic
start lies inside the iterator (same 0-based half-open interval semantics as misha tracks).
Prior adds pseudocounts; \code{extend=TRUE} pads the fetched sequence exactly as in \code{pwm},
allowing boundary-spanning motifs on any strand to be evaluated without inflating the iterator
length. If spatial weights are provided, the threshold is applied to the spatially weighted
combined score.

For all PWM functions:
\itemize{
  \item pssm: Position-specific scoring matrix (matrix or data frame with columns A,C,G,T containing frequencies; additional columns are allowed and will be ignored)
  \item bidirect: If TRUE, scans both strands and combines them per position (union).
    When TRUE, \code{strand} is ignored. If FALSE, only the strand given by \code{strand}
    is scanned (default: TRUE).
  \item prior: Pseudocount added to frequencies (default: 0.01). Set to 0 for no pseudocounts.
  \item extend: If TRUE, extends the fetched sequence so boundary-anchored motifs still
    have enough context (default: TRUE). All strand modes extend the END coordinate by
    (motif_length-1) bases. This is because at genomic position i, we always need sequence
    [i, i+motif_length) regardless of strand. Only anchors whose genomic start lies inside the
    iterator are scored/counted, regardless of the extra sequence fetched.
  \item neutral characters: By default \code{N}, \code{n}, and \code{*} are treated as unknown bases
and contribute the average log-probability of the corresponding PSSM column on both strands.
  \item strand: If 1, scans forward strand; if -1, scans reverse strand (default: 1).
    Ignored when \code{bidirect=TRUE}. For \code{pwm.max.pos}, when \code{strand == 1},
    the position of the best match is at the beginning of the match; when \code{strand == -1},
    the position is at the end of the match.
  \item score.thresh: Score threshold for pwm.count (default: 0). Only positions with
log-likelihood >= score.thresh are counted.
  \item spat_factor: Optional numeric vector of positive spatial weights (one per bin).
Weights are applied in log-space: weighted_score = log_likelihood + log(spat_factor[bin]).
If NULL (default), no spatial weighting is applied.
  \item spat_bin: Integer bin size in base pairs (required if spat_factor provided).
Must be > 0. Bins are 0-indexed from scan start: bin = floor(position / spat_bin).
  \item spat_min: Optional 1-based position defining start of scanning window (default: 1).
Use with spat_max to restrict scanning to a specific region.
  \item spat_max: Optional 1-based position defining end of scanning window (default: interval length).
Actual last scanned position may be earlier to accommodate motif length.
}

\strong{Spatial Weighting:}
Enables position-dependent weighting for modeling positional biases. Bins are 0-indexed from the
scan start. When using gvtrack.iterator() shifts (e.g., sshift=-50, eshift=50), bins index from
the expanded scan window start, not the original interval. Both strands use the same bin at each
genomic position. Positions beyond the last bin use the last bin's weight. If the window size is
not divisible by spat_bin, the last bin will be smaller (e.g., 500bp window with 40bp bins creates
bins 0-11 of 40bp each, plus bin 12 of 20bp). Use spat_min and spat_max to restrict scanning to a
range divisible by spat_bin if needed.

PWM parameters are accepted as list or individual parameters (see examples).

\emph{func = "kmer.count", params = list(kmer = "ACGT", extend = TRUE, strand = 0)} \cr
Counts occurrences of the specified kmer in each interval. The extend=TRUE
parameter (default) allows counting kmers whose start position falls within
the interval, even if the kmer extends beyond the interval boundary. With
extend=FALSE, only kmers fully contained within the interval are counted.
The strand parameter can be 1 (forward strand), -1 (reverse strand), or 0 (both strands).

\emph{func = "kmer.frac", params = list(kmer = "ACGT", extend = TRUE, strand = 0)} \cr
Calculates the fraction of possible positions in each interval that contain
the specified kmer. The extend=TRUE parameter (default) allows counting kmers
whose start position falls within the interval, even if the kmer extends beyond
the interval boundary. With extend=FALSE, only kmers fully contained within the
interval are counted. The strand parameter can be 1 (forward strand), -1
(reverse strand), or 0 (both strands).

For kmer functions:
\itemize{
  \item kmer: The DNA sequence to count (case-insensitive)
  \item extend: If TRUE (default), counts kmers whose start position is within
        the interval, even if they extend beyond. If FALSE, only counts kmers
        fully contained within the interval.
  \item strand: If 1, counts kmers on forward strand; if -1, counts kmers on reverse strand. If
 0, counts kmers on both strands. Default is 0.
}

Kmer parameters are accepted as list or individual parameters (see examples).
Note that for palindromic kmers, setting strand to 1 or -1 is recommended to avoid double counting.

Modify iterator behavior with 'gvtrack.iterator' or 'gvtrack.iterator.2d'.
}
\examples{
\dontshow{
options(gmax.processes = 2)
}

gdb.init_examples()

gvtrack.create("vtrack1", "dense_track", "max")
gvtrack.create("vtrack2", "dense_track", "quantile", 0.5)
gextract("dense_track", "vtrack1", "vtrack2",
    gintervals(1, 0, 10000),
    iterator = 1000
)

gvtrack.create("vtrack3", "dense_track", "global.percentile")
gvtrack.create("vtrack4", "annotations", "distance")
gdist(
    "vtrack3", seq(0, 1, l = 10), "vtrack4",
    seq(-500, 500, 200)
)

gvtrack.create("cov", "annotations", "coverage")
gextract("cov", gintervals(1, 0, 1000), iterator = 100)

pssm <- matrix(
    c(
        0.7, 0.1, 0.1, 0.1, # Example PSSM
        0.1, 0.7, 0.1, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1
    ),
    ncol = 4, byrow = TRUE
)
colnames(pssm) <- c("A", "C", "G", "T")
gvtrack.create(
    "motif_score", NULL, "pwm",
    list(pssm = pssm, bidirect = TRUE, prior = 0.01)
)
gvtrack.create("max_motif_score", NULL, "pwm.max",
    pssm = pssm, bidirect = TRUE, prior = 0.01
)
gvtrack.create("max_motif_pos", NULL, "pwm.max.pos",
    pssm = pssm
)
gextract(
    c(
        "dense_track", "motif_score", "max_motif_score",
        "max_motif_pos"
    ),
    gintervals(1, 0, 10000),
    iterator = 500
)

# Kmer counting examples
gvtrack.create("cg_count", NULL, "kmer.count", kmer = "CG", strand = 1)
gvtrack.create("cg_frac", NULL, "kmer.frac", kmer = "CG", strand = 1)
gextract(c("cg_count", "cg_frac"), gintervals(1, 0, 10000), iterator = 1000)

gvtrack.create("at_pos", NULL, "kmer.count", kmer = "AT", strand = 1)
gvtrack.create("at_neg", NULL, "kmer.count", kmer = "AT", strand = -1)
gvtrack.create("at_both", NULL, "kmer.count", kmer = "AT", strand = 0)
gextract(c("at_pos", "at_neg", "at_both"), gintervals(1, 0, 10000), iterator = 1000)

# GC content
gvtrack.create("g_frac", NULL, "kmer.frac", kmer = "G")
gvtrack.create("c_frac", NULL, "kmer.frac", kmer = "C")
gextract("g_frac + c_frac", gintervals(1, 0, 10000),
    iterator = 1000,
    colnames = "gc_content"
)

# Spatial PWM examples
# Create a PWM with higher weight in the center of intervals
pssm <- matrix(
    c(
        0.7, 0.1, 0.1, 0.1,
        0.1, 0.7, 0.1, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.1, 0.7
    ),
    ncol = 4, byrow = TRUE
)
colnames(pssm) <- c("A", "C", "G", "T")

# Spatial factors: low weight at edges, high in center
# For 200bp intervals with 40bp bins: bins 0, 40, 80, 120, 160
spatial_weights <- c(0.5, 1.0, 2.0, 1.0, 0.5)

gvtrack.create(
    "spatial_pwm", NULL, "pwm",
    list(
        pssm = pssm,
        bidirect = TRUE,
        spat_factor = spatial_weights,
        spat_bin = 40L
    )
)

# Compare with non-spatial PWM
gvtrack.create(
    "regular_pwm", NULL, "pwm",
    list(pssm = pssm, bidirect = TRUE)
)

gextract(c("spatial_pwm", "regular_pwm"),
    gintervals(1, 0, 10000),
    iterator = 200
)

# Using spatial parameters with iterator shifts
gvtrack.create(
    "spatial_extended", NULL, "pwm.max",
    pssm = pssm,
    spat_factor = c(0.5, 1.0, 2.0, 2.5, 2.0, 1.0, 0.5),
    spat_bin = 40L
)
# Scan window will be 280bp (100bp + 2*90bp)
gvtrack.iterator("spatial_extended", sshift = -90, eshift = 90)
gextract("spatial_extended", gintervals(1, 0, 10000), iterator = 100)

# Using spat_min/spat_max to restrict scanning to a window
# For 500bp intervals, scan only positions 30-470 (440bp window)
gvtrack.create(
    "window_pwm", NULL, "pwm",
    pssm = pssm,
    bidirect = TRUE,
    spat_min = 30, # 1-based position
    spat_max = 470 # 1-based position
)
gextract("window_pwm", gintervals(1, 0, 10000), iterator = 500)

# Combining spatial weighting with window restriction
# Scan positions 50-450 with spatial weights favoring the center
gvtrack.create(
    "window_spatial_pwm", NULL, "pwm",
    pssm = pssm,
    bidirect = TRUE,
    spat_factor = c(0.5, 1.0, 2.0, 2.5, 2.0, 1.0, 0.5, 1.0, 0.5, 0.5),
    spat_bin = 40L,
    spat_min = 50,
    spat_max = 450
)
gextract("window_spatial_pwm", gintervals(1, 0, 10000), iterator = 500)
}
\seealso{
\code{\link{gvtrack.info}}, \code{\link{gvtrack.iterator}},
\code{\link{gvtrack.iterator.2d}}, \code{\link{gvtrack.array.slice}},
\code{\link{gvtrack.ls}}, \code{\link{gvtrack.rm}}
}
\keyword{~virtual}
